//1009_4-3_時間関数time.h模写
#include<stdio.h>
#include<time.h>
int main(void)
{
	time_t now, settime;//構造体time_t型の変数nowとsettimeを宣言(実はlong型の変数) 
	//time_tはlong型の別名とは？
	//long型ってlong int型のことでは無かったの？元々は時間を扱う為の型だったの？
// →たまたま長大な値になる時刻の入れ物として丁度良かったのでlong型を使い別名つけただけ。
//「time_t」とは時刻を格納する為の型のエイリアスとtypedefで定められている。
//longよりもtime_tを使う事で異なる環境でも動作する移植性が高められているとのこと。
//異なる環境とは？具体的には？→32bitCPUは4ﾊﾞｲﾄ、64bitCPUはﾊﾞｲﾄになってしまう。

	struct tm* t1p;
	struct tm t2data; //構造体tm型ﾎﾟｲﾝﾀ型の変数t1とt2を宣言。tm型とは？どんな構造体？
	//tmはtimeの略。time_tがただの秒数だったのに対して、こちらは年月日日時分秒といった各要素に
	//分解されたカレンダーの様な構造体。メンバ(構造体の変数)に
	// 「tm_sec,tm_min,tm_hour,tm_mday(1-31),tm_mon(0-11,+1して使う),tm_year,tm_wday(曜日)」が居る

	time(&now);//time()関数---現在の時刻を1970/1/1,00:00:00を基準に取得する関数
	//文字コード的？バイナリ？的にはどんな形で取得されるの？
	//long型整数値のビットパターンがそのまま返される。
	//因みにtime()関数は戻り値でも現在の時刻を返すのでnow = time(NULL)と書ける。

	t2data.tm_sec = 0;//構造体tm型変数t2の各メンバの値を自分で決めてやる必要がある。…面倒くさい。
	t2data.tm_min = 0;
	t2data.tm_hour = 0;
	t2data.tm_mday = 0;
	t2data.tm_mon = 1;
	t2data.tm_year = 2025 - 1900;
	t2data.tm_wday = 0;//weekdayの略0〜6で日〜土を表す。
	t2data.tm_yday = 0;
	t2data.tm_isdst = 0;//isdstとは何の略？→「is daylight saving time」サマータイムであるかどうか。

	settime = mktime(&t2data);//maketime(時間を作る)の略。構造体tm型の変数t2のｱﾄﾞﾚｽだけ渡せば良いのは、
	//構造体を定義した時に各メンバのﾃﾞｰﾀ型やサイズが分かっているので、先頭ｱﾄﾞﾚｽの&t2だけ
	//分かれば、先頭から何バイト先に各メンバがいるか分かるため。
	// RDBならtmというテーブルにﾃﾞｰﾀを作ったら各列項目つまり各メンバが付随するのと似ている。
	//C言語では配列名などが先頭ｱﾄﾞﾚｽ情報だけの様に、集合的なﾃﾞｰﾀを先頭ｱﾄﾞﾚｽだけで扱うことが
	//多い。それは過去のメモリが貴重だった開発環境の影響もある

	printf("2025/1/31 00:00:00 は 1900/1/1 00:00:00 から %10d経過しています。\n", settime);//設定したt2の先頭ｱﾄﾞﾚｽ
	//をmktime()で秒数化した値settime

	printf("ctime\t:%s", ctime(&now));//time()関数で書き込んで貰った現在時刻のバイナリ値を人の理解可能文字列に変換

	printf("1900/1/1 00:00:00　から　%10d秒経過しています\n", now);
	//time()関数でnowに現在の時刻を書き込んでいるのでそれが表示
	//1970/1/1 00:00:00が基準のものあると聞いたけれど、それとの違いは？
	//そもなぜ1970年が基準になった？UNIXエポックとは？UNIX時間とは？→UNIXが本格的に開発されたのが
	// 1969〜1970年ごろだった。
	//なぜtm_yearは1900/1/1が基準？→ﾒﾓﾘは当時はとても貴重1900の差分の80で年が表示出来た。
	// localtime()とは？→現地時間。time()が返す値はUTC(協定世界時)。それを自分のPCの設定に変換する


	t1p = localtime(&now);//現地時間に調整してくれる関数。日本標準時はJST 9
	printf("loacltime:%4d/%02d %02d %02d:%02d:%02d です\n",
		t1p->tm_year + 1900,//tm_yearは1900年からの経過年数なので125に1900足してやる必要がある
		t1p->tm_mon + 1,//メンバが0〜11の数値で格納されてそれが1〜12月に対応しているので。	
		t1p->tm_mday,
		t1p->tm_hour,
		t1p->tm_min,
		t1p->tm_sec
	);
	printf("ctime\t:%s", ctime(&settime));//ctime()とはそも何？何の略？%sだけで文字列になぜ変換出来る？
	//「covert time」の略。ﾊﾞｲﾅﾘ整数値のtime_tの秒数を受け取り、それを人間が読める形でかつ、
	//char型の文字列に変換して返す動作をする。戻り値がWed Oct 8 09:45:00 2025\nの様な文字列なので
	//そのまま%sで表示が出来る。またctimeが返す文字列には\nが自動追加されているので\nは不要。
	// 
	//なんでコピーではなくて、ｱﾄﾞﾚｽ演算子で元データを変更しに行っているの？
	//C言語の古い関数では、long型の様な比較的大きなﾃﾞｰﾀは、コピーする値渡しよりもｱﾄﾞﾚｽ渡しの方が
	//わずかに効率が良いと考えられていた。では渡すのは&ではなくて*無しのﾎﾟｲﾝﾀptrとかでも良いの？
	//ポインタを渡すことで、関数にNULLを渡せるようにする。←はなぜそうなるの？
	//→「NULL」は実はどこも指していないを意味する「ﾎﾟｲﾝﾀ専用の値」だから。

	return 0;
}
/*
*time.hは疑問点がたくさん出てきて全然模写が進まないね汗。
* やっぱりmktimeという壮大な名前の割りに、設定済みの構造体tm型変数の値を秒数値に変換するだけなのなんだか名前負けに感じる
* 2025/1/31 00:00:00 は 1900/1/1 00:00:00 から 1738249200経過しています。出力がこれだけだった。どこかエラーがある。
実行結果
2025/1/31 00:00:00 は 1900/1/1 00:00:00 から 1738249200経過しています。
ctime   :Sat Oct 11 15:22:11 2025
1900/1/1 00:00:00　から　1760163731秒経過しています
loacltime:2025/10 11 15:22:11 です
ctime   :Fri Jan 31 00:00:00 2025
*/
