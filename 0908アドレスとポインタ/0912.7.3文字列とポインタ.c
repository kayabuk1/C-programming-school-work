#include<stdio.h>

int main(void) {

	char str[] = "testpoin";
	char* p = str;//strという配列名を代入しているが、
				  //この時の配列名はその配列の「先頭要素のアドレス」
			      //(&str[0]と同じ意味として)扱われる。
				  //結果としてpはstrの最初の文字't'のアドレスを指す

	printf("strは%s\n", str);//表示結果：strはtestpoin
							 //%sと言う書式指定子は指定されたアドレス
							 //からnull文字(\0)が見つかるまで、ずっと
							 //文字を表示しなさいという書式指定子

	printf("pは%s\n", p);//表示結果: pはtestpoin
						 //渡している変数はpだが、書式指定子が%sなので、%sの持つ
	                     //「指定された住所から始まる文字列を最後まで表示せよ」という意味が実行され、
						 // 上の行と同じ結果が出力される

	printf("pは%p\n", p);//表示結果: pは000000136BEFFAC8
						 //%pは「住所そのものを16進数で表示せよ」という命令。
						 //渡しているのもpと言う住所メモなので、そこに書かれている住所
						 // （アドレス）がそのまま表示される。

	printf("*pは%p\n", *p);//表示結果: *pは0000000000000074
						   //:*pは間接参照演算子「住所メモpに書かれている住所へ実際に行って、
						   // そこにある値を取ってくる」と言う命令。
						   // そして取って来るのは配列strの最初の要素't'。
						   //しかし書式指定子は%cではなく、%pなので't'をASCIIコードの116に変換し
						   //さらに16進数である74に変換して出力する。なので出力結果はアドレスではない。

	//printf("*pは%s\n", *p);
	printf("&*pは%p\n", &*p);//表示結果: &*pは000000136BEFFAC8
							 //&はアドレス演算子。変数の前に付けると、その変数がメモリ上の
							 // どこに保存されているかという住所(アドレス)を返す。
							 //分解すると、①*pで住所録pの住所に行って中身't'を取ってくる。
							 //②&(*p)と考えると、取ってきた't'が元々あった場所の住所を尋ねる。
							 // つまり&str?&'t'?
							 //結果pに書かれている住所を見ることと同じになる。

	printf("&pは%p\n", &p);//表示結果: &pは000000136BEFFAF8
						   //&pは住所録p自体の保管されている住所を聞いているので、pとは別の結果になる

	while (*p != '\0') {
		putchar(*p);
		p++;
	}
	putchar('\n');
	/*バックスラッシュ¥はエスケープシーケンス。
	¥の次に来る文字は特別な意味を持ちますよとコンパイラに伝える
	大事な合図。なのでC言語のルールとして続く文字と合わせて１文字
	として扱う。「\n」「\0」「\t」「\\」「\"」がある*/

	return 0;
}
/*実行結果
strはtestpoin
pはtestpoin
pは000000136BEFFAC8
*pは0000000000000074
&*pは000000136BEFFAC8
&pは000000136BEFFAF8
testpoin
*/