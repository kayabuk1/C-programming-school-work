#include<stdio.h>

int main(void)
{
	char str[] = "testpoin";
	char* p = str;
  //char* p =&str[0];と同じ意味
	/*strという配列名を代入している。
	* この時の配列名はその配列の「先頭要素のアドレス（&str[0]と同じ意味）」として扱われる。
	* 結果としてpは最初の文字't'のアドレスを指す。
	* C言語ではsizeof演算子に配列名を入れる場合等を除くほとんどの場合で、
	「配列名＝その配列の先頭要素のアドレス」と考えて問題ない。
	*/

	printf("strは%s\n", str);//*表示結果：strはtestpoin
	printf("strは");//↑は↓と同じ動作をする。
	while (*p != '\0') {
		putchar(*p);
		p++;
	}
	putchar('\n');//strはtestpoin
	/*%sという書式指定子は、
	*「指定されたアドレスからnull文字（\0）が見つかるまでずっと文字を表示しなさい」
	*という意味をを持つ書式指定子。
	* コンパイラは&str[0]='t'〜str[7]='\0'までを順に表示する。
	*/
	
	printf("pは%s\n", p);//表示結果: pはtestpoin
	/*渡している変数はアドレスが格納されているポインタ変数「p」だが、
	* 書式指定子が%sなので、%sの持つ「指定された住所から始まる文字列を最後まで表示せよ」と言う
	* 意味が実行され、コンパイラには&str[0]が渡されるので、上の行と同じ結果が出力される。
	*/

	printf("pは%p\n", p);///*表示結果: pは000000136BEFFAC8
	printf("pは%ld\n", (long)p);//表示結果:pは1511978888 long型で無理やり整数型で表示することも出来るが何もメリットはない。
	/*%pは「住所そのものを16進数で表示せよ」という意味。
	* 渡しているものも「p」と言う住所メモなので、pに書かれている住所（格納されているアドレス）が
	* そのまま表示される。16進数として表示される場合、先頭に0xが付くことも多い。
	* 「%p」が記載された時、期待される引数の型は「void*(型を問わない汎用ポインタ)」とのこと。
	* char*やint*等他の型のポインタを渡しても正しく動作するのは、引数として渡される際に、
	* 暗黙的に「void*」に変換されるから。つまりpがどんな型のポインタであっても、問題ない。
	*/

	printf("*pは%p\n", *p);//*pは0000000000000074
	printf("*pは%d\n", *p);//*pは116
	printf("*pは%c\n", *p);//*pはt
  //printf("*pは%s\n", *p);//%sに渡すのは文字列ｱﾄﾞﾚｽでなければならないのでエラーになる。
  //*pはあくまで変数1つ分しか操作出来ない。文字列でひと固まりと考えてはいけない。
	/*「%p」は間接参照演算子「住所メモpに書かれている住所へ行って、そこにある値を取ってくる」と言う意味になる。
	* そして取ってくるのは、char*p=str;で代入された配列strの最初の要素't'(配列名=その配列の先頭要素アドレスなので)。
	* しかし書式指定子は%cではなく、%pなので't'をASCIIコードの116に変換、更に16進数である74に変換して出力する。
	*/

	printf("&*pは%s\n", &*p);//&*pはtestpoin　&と*で打ち消しあって&*p==pになると考えて良い。
	printf("&*pは%p\n", &*p);//pは000000136BEFFAC8　なので%pではpが渡されてアドレスが表示される。

	printf("&pは%p\n", &p);//&pは000000AA3A8FFD48　メモp自体の保管されている住所を聞いているので、pとは別の結果になる。
	
	return 0;
}